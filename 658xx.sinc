# sleigh specification file for WDC 65816


define endian=little;
define alignment=1;

define space RAM       type=ram_space       size=3  default;
define space register  type=register_space  size=1;

define register offset=0x00  size=3  [ PC_FULL ];
define register offset=0x00  size=2  [ PC ];
define register offset=0x02  size=1  [ PBR ];

define register offset=0x10  size=2  [ C   X      Y      DP  SP ];
define register offset=0x10  size=1  [ A B XLow _ YLow _ _ _ _ _ ];
define register offset=0x20  size=1  [ DBR ];

# Status flags.
# TODO: remove MF, XF, DF, EF flags, then rename and use context?
define register offset=0x30  size=1  [ NF VF MF XF DF IF ZF CF EF BF ];
define register offset=0x40  size=4  contextreg;
define context contextreg
    is_m8=(0,0)
    is_x8=(1,1)
    is_dec=(2,2)
    is_emu=(3,3)
;


define token opbyte (8)
   op       = (0,7)

   aaa      = (5,7)
   bbb      = (2,4)
   cc       = (0,1)
;

define token data8 (8)
   imm8     = (0,7)
   srcbk    = (0,7)
   destbk   = (0,7)
   rel      = (0,7) signed
;

define token data16 (16)
    imm16 = (0,15)
;

define token data24 (24)
    imm24 = (0,23)
;

macro make_addr24(_out, _bank, _addr16) {
    local bank8:1 = _bank;
    local addr16:2 = _addr16;

    local bank24:3 = zext(bank8);
    local addr24:3 = zext(addr16);
    local result:3 = (bank24 << 16) | addr24;
    _out = result;
}

macro calculate_dp_addr24(_out, _offset8) {
    local offset8:1 = _offset8;
    local result:3;

    if ((EF == 1) && ((DP & 0xFF) == 0)) goto <emu>;
    goto <not_emu>;

    <emu>
    result = zext(offset8);
    goto <end>;

    <not_emu>
    local offset16:2 = zext(offset8);
    # This is modulo 16 bits, always in bank 0.
    local addr16:2 = DP + offset16;
    result = zext(addr16);

    <end>
    _out = result;
}

macro calculate_dp_addr24_no_emu(_out, _offset8) {
    local offset8:1 = _offset8;
    local result:3;

    local offset16:2 = zext(offset8);
    # This is modulo 16 bits.
    local addr16:2 = DP + offset16;
    result = zext(addr16);

    _out = result;
}

macro read16_dp_offset(_out, _offset8) {
    local offset8:1 = _offset8;

    local addrLo:3;
    calculate_dp_addr24(addrLo, offset8);
    local addrHi:3;
    calculate_dp_addr24(addrHi, offset8 + 1);

    local lo:1 = *addrLo;
    local hi:1 = *addrHi;
    local value:2 = (zext(hi) << 8) | zext(lo);
    _out = value;
}

macro read24_dp_offset(_out, _offset8) {
    local offset8:1 = _offset8;

    local addrLo:3;
    calculate_dp_addr24(addrLo, offset8);
    local addrHi:3;
    calculate_dp_addr24(addrHi, offset8 + 1);
    local addrBank:3;
    calculate_dp_addr24(addrBank, offset8 + 2);

    local lo:1 = *addrLo;
    local hi:1 = *addrHi;
    local bank:1 = *addrBank;
    local value:3 = (zext(bank) << 16) | (zext(hi) << 8) | zext(lo);
    _out = value;
}

macro flag8_N(_acc) {
    local acc:1 = _acc;
    NF = (acc & 0x80) != 0;
}

macro flag8_Z(_acc) {
    local acc:1 = _acc;
    ZF = acc == 0;
}

macro flag8_NZ(_acc) {
    flag8_N(_acc);
    flag8_Z(_acc);
}

macro flag16_N(_acc) {
    local acc:2 = _acc;
    NF = (acc & 0x8000) != 0;
}

macro flag16_Z(_acc) {
    local acc:2 = _acc;
    ZF = acc == 0;
}

macro flag16_NZ(_acc) {
    flag16_N(_acc);
    flag16_Z(_acc);
}

macro push8(_val8) {
    local value:1 = _val8;
    local sp:3 = zext(SP);
    *:1 sp = value;
    SP = SP - 1;
}

macro push16(_val16) {
    local value:2 = _val16;
    local sp:3;

    # High byte.
    sp = zext(SP);
    *:1 sp = value(1);
    SP = SP - 1;

    # Low byte.
    sp = zext(SP);
    *:1 sp = value:1;
    SP = SP - 1;
}

macro pull8(var8) {
    SP = SP + 1;
    local sp:3 = zext(SP);
    var8 = *:1 sp;
}

macro pull16(var16) {
    local sp:3;

    # Low byte.
    SP = SP + 1;
    sp = zext(SP);
    var16[0,8] = *:1 sp;

    # High byte.
    SP = SP + 1;
    sp = zext(SP);
    var16[8,8] = *:1 sp;
}

macro push_status_native() {
    local status:1;
    status[7,1] = NF;
    status[6,1] = VF;
    status[5,1] = MF;
    status[4,1] = XF;
    status[3,1] = DF;
    status[2,1] = IF;
    status[1,1] = ZF;
    status[0,1] = CF;
    push8(status);
}

macro push_status_emulation() {
    local status:1 = 0;
    status[7,1] = NF;
    status[6,1] = VF;
    # bit 5 unused
    status[4,1] = BF;
    status[3,1] = DF;
    status[2,1] = IF;
    status[1,1] = ZF;
    status[0,1] = CF;
    push8(status);
}

macro pull_status_native() {
    local status:1;
    pull8(status);
    NF = status[7,1];
    VF = status[6,1];
    MF = status[5,1];
    XF = status[4,1];
    DF = status[3,1];
    IF = status[2,1];
    ZF = status[1,1];
    CF = status[0,1];
}

macro pull_status_emulation() {
    local status:1;
    pull8(status);
    NF = status[7,1];
    VF = status[6,1];
    # bit 5 unused
    BF = status[4,1];
    DF = status[3,1];
    IF = status[2,1];
    ZF = status[1,1];
    CF = status[0,1];
}


# Addressing modes for primary group instructions (ADC AND CMP EOR LDA ORA SBC STA).
# TODO: deal with 65802/65816 in native/emulation modes?
# TODO: is explicit use of const space necessary?

# In the 6502/65C02, the effective address formed using zero page indexed addressing from a zero page
# base address of $F0 and an index of $20 is $10; that is, zero page indexed effective addresses wrap around to
# always remain in the zero page. In the emulation mode this is also true. But in native mode, there is no page
# wraparound: a direct page starting at $2000 combined with a direct page base of $20 and a sixteen-bit index
# holding $300 results in an effective address of $2320.  (p52)

# [Speaking about the 65802] While the direct page can be set to the zero page, direct page indexed addresses can cross pages
# in native mode, but wrap on the 6502.  (p58)

# Index wrapping is described on p98.
# Addressing mode syntax on p155.

# [Speaking about the 658xx] Pay particular attention to the peculiarities of the direct page in the emulation mode: as with the 6502
# and 65C02, instructions which use direct page addressing modes will [appear to?] “wrap” to stay within the zero page, but
# only when the direct page register is equal to zero. Opcodes which are not found on the 6502 or 65C02 will not
# wrap at all, even when the direct page is equal to zero in the emulation mode.  (p278)

# Absolute.
# Always with DBR for the primary group instructions. No change when emulation mode.
ADDR_ABS: !$imm16    is imm16  {
    local tmp:3;
    make_addr24(tmp, DBR, imm16);
    export *:2 tmp;
}

# Absolute long.
# No change when emulation mode, this does not exist on the 6502.
ADDR_ABS_LONG: >$imm24    is imm24  {
    local tmp:3 = imm24;
    export *:2 tmp;
}

# Direct page.
# Emulation mode may cause offset to wrap.
ADDR_DP: <$imm8    is imm8  {
    local tmp:3;
    calculate_dp_addr24(tmp, imm8);
    export *:2 tmp;
}

# Direct page indirect.
# No change when emulation mode, this does not exist on the 6502.
ADDR_DP_IND: ($imm8)    is imm8  {
    local ind:3;
    calculate_dp_addr24_no_emu(ind, imm8);

    local addr16:2 = * ind;

    local ea:3;
    make_addr24(ea, DBR, addr16);
    export *:2 ea;
}

# Direct page indirect long.
# No change when emulation mode, this does not exist on the 6502.
ADDR_DP_IND_LONG: [$imm8]    is imm8  {
    local ind:3;
    calculate_dp_addr24_no_emu(ind, imm8);

    local ea:3 = * ind;
    export *:2 ea;
}

# Absolute indexed X.
# TODO don't think this is affected by emulation mode?
ADDR_ABS_IDX_X: !$imm16,"X"    is imm16  {
    local base:3;
    make_addr24(base, DBR, imm16);

    local idx:2 = X;
    if (XF == 0) goto <skip_idx8>;
    idx = zext(XLow);
    <skip_idx8>

    local ea:3 = base + zext(idx);
    export *:2 ea;
}

# Absolute long indexed X.
# No change when emulation mode.
ADDR_ABS_LONG_IND_X: >$imm24,"X"    is imm24  {
    local base:3 = imm24;

    local idx:2 = X;
    if (XF == 0) goto <skip_idx8>;
    idx = zext(XLow);
    <skip_idx8>

    local ea:3 = base + zext(idx);
    export *:2 ea;
}

# Absolute indexed Y.
# TODO don't think this is affected by emulation mode?
ADDR_ABS_IDX_Y: !$imm16,"Y"    is imm16  {
    local base:3;
    make_addr24(base, DBR, imm16);

    local idx:2 = Y;
    if (XF == 0) goto <skip_idx8>;
    idx = zext(YLow);
    <skip_idx8>

    local ea:3 = base + zext(idx);
    export *:2 ea;
}

# Accumulator.
ADDR_ACC: "A"    is epsilon  {
    export *:2 C;
}

# Direct page indexed X.
# Emulation mode may restrict addresses to the zero page.
# TODO: check against higan.
ADDR_DP_IDX_X: $imm8,"X"    is imm8  {
    local idx:2 = X;
    if (XF == 0) goto <skip_idx8>;
    idx = zext(XLow);
    <skip_idx8>

    # DP + imm8 + X, then set bank to 0.
    local imm8_1:1 = imm8;
    local imm8_2:2 = zext(imm8_1);
    local ea:3 = zext(DP + imm8_2 + idx);

    # Restrict to the zero page if emulation mode and DP=0.
    if (!( (EF==1) && (DP == 0) )) goto <skip_emu>;
    ea = ea & 0xFF;
    <skip_emu>

    export *:2 ea;
}

# Direct page indexed Y.
# Emulation mode may restrict addresses to the zero page.
# TODO: check against higan.
ADDR_DP_IDX_Y: $imm8,"Y"    is imm8  {
    local idx:2 = Y;
    if (XF == 0) goto <skip_idx8>;
    idx = zext(YLow);
    <skip_idx8>

    # DP + imm8 + Y, then set bank to 0.
    local imm8_1:1 = imm8;
    local imm8_2:2 = zext(imm8_1);
    local ea:3 = zext(DP + imm8_2 + idx);

    # Restrict to the zero page if emulation mode and DP=0.
    if (!( (EF==1) && (DP == 0) )) goto <skip_emu>;
    ea = ea & 0xFF;
    <skip_emu>

    export *:2 ea;
}

# Direct page indexed indirect X.
# Emulation mode restricts indirection addresses to the direct page.
# TODO: check against higan, use DP macro?
ADDR_DP_IDX_X_IND: (<$imm8,"X")    is imm8  {
    local idx:2 = X;
    # For this constructor sleigh has decided that it can't infer the bool size for some reason...
    local is_not_idx8:1 = XF == 0;
    if (is_not_idx8) goto <skip_idx8>;
    idx = zext(XLow);
    <skip_idx8>

    local ind:3;
    local is_not_emu:1 = EF == 0;
    if (is_not_emu) goto <not_emu>;

    <emu>
    # When the offset exceeds 0xFF it wraps.
    offset:2 = zext(imm8) + idx;
    ind = zext(DP + offset);
    goto <end>;

    <not_emu>
    # The indirection address wraps to stay in bank 0.
    ind = zext(DP + zext(imm8) + idx);

    <end>

    local ea:3;
    make_addr24(ea, DBR, (*:2 ind));

    export *:2 ea;
}

# Direct page indirect, indexed Y.
# "The array of memory accessible to the indirect indexed addressing mode can extend beyond the
# current 64K data bank into the next 64K bank, if the index plus the array base exceeds $FFFF."
ADDR_DP_IND_IDX_Y: ($imm8),"Y"    is imm8  {
    local ind:2;
    read16_dp_offset(ind, imm8);

    local base_ea:3;
    make_addr24(base_ea, DBR, ind);

    local idx:3 = zext(Y);
    if (XF == 0) goto <skip_idx8>;
    idx = zext(YLow);
    <skip_idx8>

    local ea:3 = base_ea + idx;
    export *:2 ea;
}

# Direct page indirect long, indexed Y.
ADDR_DP_IND_LONG_IDX_Y: [$imm8],"Y"    is imm8  {
    local ind:3;
    read24_dp_offset(ind, imm8);

    local idx:3 = zext(Y);
    if (XF == 0) goto <skip_idx8>;
    idx = zext(YLow);
    <skip_idx8>

    local ea:3 = ind + idx;
    export *:2 ea;
}

# Stack relative.
ADDR_SR: $imm8,"S"    is imm8  {
    local imm8_1:1 = imm8;
    local imm8_2:2 = zext(imm8_1);

    local addr16:2 = SP + imm8_2;
    local tmp:3;
    make_addr24(tmp, 0, addr16);
    export *:2 tmp;
}

# Stack relative indirect, indexed Y.
ADDR_SR_IND_IDX_Y: ($imm8,"S"),"Y"    is imm8  {
    local imm8_1:1 = imm8;
    local stack_addr16:2 = SP + zext(imm8_1);

    local ind_lo_addr:3;
    make_addr24(ind_lo_addr, 0, stack_addr16);
    local ind_lo:1 = *ind_lo_addr;
    local ind_hi_addr:3;
    make_addr24(ind_hi_addr, 0, stack_addr16 + 1);
    local ind_hi:1 = *ind_hi_addr;
    local ind:2 = (zext(ind_hi) << 8) | zext(ind_lo);

    local ea_base:3;
    make_addr24(ea_base, DBR, ind);

    local idx:3 = zext(Y);
    if (XF == 0) goto <skip_idx8>;
    idx = zext(YLow);
    <skip_idx8>

    local ea:3 = ea_base + idx;
    export *:2 ea;
}

# Immediate, 8 bit mode.
ADDR_IMM: #$imm8    is is_m8=1; imm8  {
    local imm8_1:1 = imm8;
    local value:2 = zext(imm8_1);
    export value;
}

# Immediate, 16 bit mode.
ADDR_IMM: #$imm16    is is_m8=0; imm16  {
    local value:2 = imm16;
    export value;
}

# Two subsets of the addressing modes for the primary group instructions
# (ADC, AND, CMP, EOR, LDA, ORA, SBC, STA).
#
# PRIMARY_OP_NO_IMM is the whole subset except for ADDR_IMM (can't STA to an immediate).
#
PRIMARY_OP_NO_IMM: ADDR_ABS    is bbb=3 & cc=1; ADDR_ABS  { export ADDR_ABS; }
PRIMARY_OP_NO_IMM: ADDR_ABS_LONG    is bbb=3 & cc=3; ADDR_ABS_LONG  { export ADDR_ABS_LONG; }
PRIMARY_OP_NO_IMM: ADDR_DP    is bbb=1 & cc=1; ADDR_DP  { export ADDR_DP; }
PRIMARY_OP_NO_IMM: ADDR_DP_IND    is bbb=4 & cc=2; ADDR_DP_IND  { export ADDR_DP_IND; }
PRIMARY_OP_NO_IMM: ADDR_DP_IND_LONG    is bbb=1 & cc=3; ADDR_DP_IND_LONG  { export ADDR_DP_IND_LONG; }
PRIMARY_OP_NO_IMM: ADDR_ABS_IDX_X    is bbb=7 & cc=1; ADDR_ABS_IDX_X  { export ADDR_ABS_IDX_X; }
PRIMARY_OP_NO_IMM: ADDR_ABS_LONG_IND_X    is bbb=7 & cc=3; ADDR_ABS_LONG_IND_X  { export ADDR_ABS_LONG_IND_X; }
PRIMARY_OP_NO_IMM: ADDR_ABS_IDX_Y    is bbb=6 & cc=1; ADDR_ABS_IDX_Y  { export ADDR_ABS_IDX_Y; }
PRIMARY_OP_NO_IMM: ADDR_DP_IDX_X    is bbb=5 & cc=1; ADDR_DP_IDX_X  { export ADDR_DP_IDX_X; }
PRIMARY_OP_NO_IMM: ADDR_DP_IDX_X_IND    is bbb=0 & cc=1; ADDR_DP_IDX_X_IND  { export ADDR_DP_IDX_X_IND; }
PRIMARY_OP_NO_IMM: ADDR_DP_IND_IDX_Y    is bbb=4 & cc=1; ADDR_DP_IND_IDX_Y  { export ADDR_DP_IND_IDX_Y; }
PRIMARY_OP_NO_IMM: ADDR_DP_IND_LONG_IDX_Y    is bbb=5 & cc=3; ADDR_DP_IND_LONG_IDX_Y  { export ADDR_DP_IND_LONG_IDX_Y; }
PRIMARY_OP_NO_IMM: ADDR_SR    is bbb=0 & cc=3; ADDR_SR  { export ADDR_SR; }
PRIMARY_OP_NO_IMM: ADDR_SR_IND_IDX_Y    is bbb=4 & cc=3; ADDR_SR_IND_IDX_Y  { export ADDR_SR_IND_IDX_Y; }
#
# PRIMARY_OP is the whole subset.
#
PRIMARY_OP: PRIMARY_OP_NO_IMM    is PRIMARY_OP_NO_IMM  { export PRIMARY_OP_NO_IMM; }
PRIMARY_OP: ADDR_IMM    is bbb=2 & cc=1; ADDR_IMM  { export ADDR_IMM; }

# Subsets of the addressing modes for some secondary instructions (most of the remaining
# instructions that aren't branches/jumps and don't use implied addressing).
#
SEC_OP_COMMON: ADDR_ABS    is bbb=3; ADDR_ABS  { export ADDR_ABS; }
SEC_OP_COMMON: ADDR_DP    is bbb=1; ADDR_DP  { export ADDR_DP; }
#
SEC_OP_X: SEC_OP_COMMON    is SEC_OP_COMMON  { export SEC_OP_COMMON; }
SEC_OP_X: ADDR_ABS_IDX_X    is bbb=7; ADDR_ABS_IDX_X  { export ADDR_ABS_IDX_X; }
SEC_OP_X: ADDR_DP_IDX_X    is bbb=5; ADDR_DP_IDX_X  { export ADDR_DP_IDX_X; }
#
SEC_OP_Y: SEC_OP_COMMON    is SEC_OP_COMMON  { export SEC_OP_COMMON; }
SEC_OP_Y: ADDR_ABS_IDX_Y    is bbb=7; ADDR_ABS_IDX_Y  { export ADDR_ABS_IDX_Y; }
SEC_OP_Y: ADDR_DP_IDX_Y    is bbb=5; ADDR_DP_IDX_Y  { export ADDR_DP_IDX_Y; }


# Begin instructions.

# ADC with decimal mode is unimplemented.
:ADC PRIMARY_OP    is (is_dec=1 &
    (op=0x69 | op=0x6d | op=0x6f | op=0x65 | op=0x72 | op=0x67 | op=0x7d |
     op=0x7f | op=0x79 | op=0x75 | op=0x61 | op=0x71 | op=0x77 | op=0x63 |
     op=0x73)) ... & PRIMARY_OP  unimpl

# ADC 8 bit binary.
:ADC PRIMARY_OP    is (is_dec=0 & is_m8=1 &
    (op=0x69 | op=0x6d | op=0x6f | op=0x65 | op=0x72 | op=0x67 | op=0x7d |
     op=0x7f | op=0x79 | op=0x75 | op=0x61 | op=0x71 | op=0x77 | op=0x63 |
     op=0x73)) ... & PRIMARY_OP
{
    local data:1 = PRIMARY_OP:1;
    local result:4;

    result = zext(A) + zext(data) + zext(CF);
    VF = (~zext(A ^ data) & (zext(A) ^ result) & 0x80) != 0;
    CF = result s> 0xFF;

    local result8:1 = result:1;
    flag8_NZ(result8);
    A = result8;
}

# ADC 16 bit binary.
:ADC PRIMARY_OP    is (is_dec=0 & is_m8=0 &
    (op=0x69 | op=0x6d | op=0x6f | op=0x65 | op=0x72 | op=0x67 | op=0x7d |
     op=0x7f | op=0x79 | op=0x75 | op=0x61 | op=0x71 | op=0x77 | op=0x63 |
     op=0x73)) ... & PRIMARY_OP
{
    local data:2 = PRIMARY_OP:2;
    local result:4;

    result = zext(C) + zext(data) + zext(CF);
    VF = (~zext(C ^ data) & (zext(C) ^ result) & 0x8000) != 0;
    CF = result s> 0xFFFF;

    local result16:2 = result:2;
    flag16_NZ(result16);
    C = result16;
}

# AND 8 bit.
:AND PRIMARY_OP    is (aaa=1 & is_m8=1) ... & PRIMARY_OP
{
    local data:1 = PRIMARY_OP:1;

    A = A & data;
    flag8_NZ(A);
}

# AND 16 bit.
:AND PRIMARY_OP    is (aaa=1 & is_m8=0) ... & PRIMARY_OP
{
    local data:2 = PRIMARY_OP:2;

    C = C & data;
    flag16_NZ(C);
}

SHIFT_OP: SEC_OP_X    is SEC_OP_X  { export SEC_OP_X; }
SHIFT_OP: ADDR_ACC    is bbb=2; ADDR_ACC  { export ADDR_ACC; }

# ASL 8 bit.
:ASL SHIFT_OP    is (is_m8=1 &
    (op=0x0a | op=0x0e | op=0x06 | op=0x1e | op=0x16)) ... & SHIFT_OP
{
    local data:1 = SHIFT_OP:1;
    local result:1 = data << 1;

    SHIFT_OP[0,8] = result;
    flag8_NZ(result);
    CF = data[7,1];
}

# ASL 16 bit.
:ASL SHIFT_OP    is (is_m8=0 &
    (op=0x0a | op=0x0e | op=0x06 | op=0x1e | op=0x16)) ... & SHIFT_OP
{
    local data:2 = SHIFT_OP;
    local result:2 = data << 1;

    SHIFT_OP = result;
    flag16_NZ(result);
    CF = data[15,1];
}

BIT_OP: SEC_OP_X    is (aaa=1 & cc=0) ... & SEC_OP_X  { export SEC_OP_X; }
BIT_OP: ADDR_IMM    is op=0x89; ADDR_IMM  { export ADDR_IMM; }

# BIT 8 bit.
:BIT BIT_OP    is (is_m8=1 &
    (op=0x89 | op=0x2c | op=0x24 | op=0x3c | op=0x34) & op) ... & BIT_OP
{
    local data:1 = BIT_OP:1;
    local is_immediate:1 = op:1 == 0x89;

    if (is_immediate) goto <skip_flags>;
    flag8_N(data);
    VF = (data & 0x40) != 0;

    <skip_flags>
    local result:1 = A & data;
    flag8_Z(result);
}

# BIT 16 bit.
:BIT BIT_OP    is (is_m8=0 &
    (op=0x89 | op=0x2c | op=0x24 | op=0x3c | op=0x34) & op) ... & BIT_OP
{
    local data:2 = BIT_OP:2;
    local is_immediate:1 = op:1 == 0x89;

    if (is_immediate) goto <skip_flags>;
    flag16_N(data);
    VF = (data & 0x4000) != 0;

    <skip_flags>
    local result:2 = C & data;
    flag16_Z(result);
}

:BRK    is op=0x00 & is_emu
{
    local pc_inc:2 = PC + 2;
    local target:3;
    local is_emulation:1 = is_emu == 1;
    if (is_emulation) goto <do_emulation>;

    <do_native>
    push8(PBR);
    push16(pc_inc);
    push_status_native();
    IF = 1;
    DF = 0;
    PBR = 0;
    target = zext(*:2 0x00FFE6:3);
    goto <end>;

    <do_emulation>
    push16(pc_inc);
    local save_bf:1 = BF;  BF = 1;  push_status_emulation();  BF = save_bf;
    IF = 1;
    DF = 0;
    target = zext(*:2 0x00FFFE:3);

    <end>
    call [target];
}

:CLC    is op=0x18
{
    CF = 0;
}

:CLD    is op=0xD8
{
    DF = 0;
}

:CLI    is op=0x58
{
    IF = 0;
}

:CLV    is op=0xB8
{
    VF = 0;
}

# CMP 8 bit.
:CMP PRIMARY_OP    is (is_m8=1 &
    (op=0xc9 | op=0xcd | op=0xcf | op=0xc5 | op=0xd2 | op=0xc7 | op=0xdd |
     op=0xdf | op=0xd9 | op=0xd5 | op=0xc1 | op=0xd1 | op=0xd7 | op=0xc3 |
     op=0xd3)) ... & PRIMARY_OP
{
    local data:1 = PRIMARY_OP:1;
    local result:4;

    result = sext(A) - sext(data);
    flag8_NZ(result:1);
    CF = result s>= 0;
}

# CMP 16 bit.
:CMP PRIMARY_OP    is (is_m8=0 &
    (op=0xc9 | op=0xcd | op=0xcf | op=0xc5 | op=0xd2 | op=0xc7 | op=0xdd |
     op=0xdf | op=0xd9 | op=0xd5 | op=0xc1 | op=0xd1 | op=0xd7 | op=0xc3 |
     op=0xd3)) ... & PRIMARY_OP
{
    local data:2 = PRIMARY_OP:2;
    local result:4;

    result = sext(C) - sext(data);
    flag16_NZ(result:2);
    CF = result s>= 0;
}

:COP    is op=0x02 & is_emu
{
    local pc_inc:2 = PC + 2;
    local target:3;
    local is_emulation:1 = is_emu == 1;
    if (is_emulation) goto <do_emulation>;

    <do_native>
    push8(PBR);
    push16(pc_inc);
    push_status_native();
    IF = 1;
    DF = 0;
    PBR = 0;
    target = zext(*:2 0x00FFE4:3);
    goto <end>;

    <do_emulation>
    push16(pc_inc);
    push_status_emulation();
    IF = 1;
    DF = 0;
    target = zext(*:2 0x00FFF4:3);

    <end>
    call [target];
}

CPXY_OP: SEC_OP_COMMON    is (cc=0) ... & SEC_OP_COMMON  { export SEC_OP_COMMON; }
CPXY_OP: ADDR_IMM    is bbb=0; ADDR_IMM  { export ADDR_IMM; }

# CPX 8 bit.
:CPX CPXY_OP    is (is_m8=1 & (op=0xe0 | op=0xec | op=0xe4)) ... & CPXY_OP {
    local result:4 = sext(XLow) - sext(CPXY_OP:1);
    flag8_NZ(result:1);
    CF = result s>= 0;
}

# CPX 16 bit.
:CPX CPXY_OP    is (is_m8=0 & (op=0xe0 | op=0xec | op=0xe4)) ... & CPXY_OP {
    local result:4 = sext(X) - sext(CPXY_OP:2);
    flag16_NZ(result:2);
    CF = result s>= 0;
}

# CPY 8 bit.
:CPY CPXY_OP    is (is_m8=0 & (op=0xc0 | op=0xcc | op=0xc4)) ... & CPXY_OP {
    local result:4 = sext(YLow) - sext(CPXY_OP:1);
    flag8_NZ(result:1);
    CF = result s>= 0;
}

# CPY 16 bit.
:CPY CPXY_OP    is (is_m8=1 & (op=0xc0 | op=0xcc | op=0xc4)) ... & CPXY_OP {
    local result:4 = sext(Y) - sext(CPXY_OP:2);
    flag16_NZ(result:2);
    CF = result s>= 0;
}

DEC_INC_OP: SEC_OP_X    is (cc=2) ... & SEC_OP_X  { export SEC_OP_X; }
DEC_INC_OP: ADDR_ACC    is (bbb=6) ... & ADDR_ACC  { export ADDR_ACC; }

# DEC 8 bit.
:DEC DEC_INC_OP    is (is_m8=1 &
    (op=0x3a | op=0xce | op=0xc6 | op=0xde | op=0xd6)) ... & DEC_INC_OP
{
    local result:1 = DEC_INC_OP:1 - 1;
    flag8_NZ(result);
    DEC_INC_OP[0,8] = result;
}

# DEC 16 bit.
:DEC DEC_INC_OP    is (is_m8=0 &
    (op=0x3a | op=0xce | op=0xc6 | op=0xde | op=0xd6)) ... & DEC_INC_OP
{
    local result:2 = DEC_INC_OP:2 - 1;
    flag16_NZ(result);
    DEC_INC_OP = result;
}

# DEX 8 bit.
:DEX    is (is_m8=1 & op=0xca)
{
    local result:1 = XLow - 1;
    flag8_NZ(result);
    XLow = result;
}

# DEX 16 bit.
:DEX    is (is_m8=0 & op=0xca)
{
    local result:2 = X - 1;
    flag16_NZ(result);
    X = result;
}

# DEY 8 bit.
:DEY    is (is_m8=1 & op=0x88)
{
    local result:1 = YLow - 1;
    flag8_NZ(result);
    YLow = result;
}

# DEY 16 bit.
:DEY    is (is_m8=0 & op=0x88)
{
    local result:2 = Y - 1;
    flag16_NZ(result);
    Y = result;
}

# EOR 8 bit.
:EOR PRIMARY_OP    is (is_m8=1 &
    (op=0x49 | op=0x4d | op=0x4f | op=0x45 | op=0x52 | op=0x47 | op=0x5d |
     op=0x5f | op=0x59 | op=0x55 | op=0x41 | op=0x51 | op=0x57 | op=0x43 |
     op=0x53)) ... & PRIMARY_OP
{
    local data:1 = PRIMARY_OP:1;

    A = A ^ data;
    flag8_NZ(A);
}

# EOR 16 bit.
:EOR PRIMARY_OP    is (is_m8=0 &
    (op=0x49 | op=0x4d | op=0x4f | op=0x45 | op=0x52 | op=0x47 | op=0x5d |
     op=0x5f | op=0x59 | op=0x55 | op=0x41 | op=0x51 | op=0x57 | op=0x43 |
     op=0x53)) ... & PRIMARY_OP
{
    local data:2 = PRIMARY_OP:2;

    C = C ^ data;
    flag16_NZ(C);
}

# INC 8 bit.
:INC DEC_INC_OP    is (is_m8=1 &
    (op=0x1a | op=0xee | op=0xe6 | op=0xfe | op=0xf6)) ... & DEC_INC_OP
{
    local result:1 = DEC_INC_OP:1 + 1;
    flag8_NZ(result);
    DEC_INC_OP[0,8] = result;
}

# INC 16 bit.
:INC DEC_INC_OP    is (is_m8=0 &
    (op=0x1a | op=0xee | op=0xe6 | op=0xfe | op=0xf6)) ... & DEC_INC_OP
{
    local result:2 = DEC_INC_OP:2 + 1;
    flag16_NZ(result);
    DEC_INC_OP = result;
}

# INX 8 bit.
:INX    is (is_m8=1 & op=0xe8)
{
    local result:1 = XLow + 1;
    flag8_NZ(result);
    XLow = result;
}

# INX 16 bit.
:INX    is (is_m8=0 & op=0xe8)
{
    local result:2 = X + 1;
    flag16_NZ(result);
    X = result;
}

# INY 8 bit.
:INY    is (is_m8=1 & op=0xc8)
{
    local result:1 = YLow + 1;
    flag8_NZ(result);
    YLow = result;
}

# INY 16 bit.
:INY    is (is_m8=0 & op=0xc8)
{
    local result:2 = Y + 1;
    flag16_NZ(result);
    Y = result;
}

# LDA 8 bit.
:LDA PRIMARY_OP    is (is_m8=1 &
    (op=0xa9 | op=0xad | op=0xaf | op=0xa5 | op=0xb2 | op=0xa7 | op=0xbd |
     op=0xbf | op=0xb9 | op=0xb5 | op=0xa1 | op=0xb1 | op=0xb7 | op=0xa3 |
     op=0xb3)) ... & PRIMARY_OP
{
    local data:1 = PRIMARY_OP:1;

    A = data;
    flag8_NZ(A);
}

# LDA 16 bit.
:LDA PRIMARY_OP    is (is_m8=0 &
    (op=0xa9 | op=0xad | op=0xaf | op=0xa5 | op=0xb2 | op=0xa7 | op=0xbd |
     op=0xbf | op=0xb9 | op=0xb5 | op=0xa1 | op=0xb1 | op=0xb7 | op=0xa3 |
     op=0xb3)) ... & PRIMARY_OP
{
    local data:2 = PRIMARY_OP:2;

    C = data;
    flag16_NZ(C);
}

LDX_OP: SEC_OP_Y    is (aaa=5) ... & SEC_OP_Y  { export SEC_OP_Y; }
LDX_OP: ADDR_IMM    is (bbb=0) ... & ADDR_IMM  { export ADDR_IMM; }

# LDX 8 bit.
:LDX LDX_OP    is (is_m8=1 &
    (op=0xa2 | op=0xae | op=0xa6 | op=0xbe | op=0xb6)) ... & LDX_OP
{
    local data:1 = LDX_OP:1;
    flag8_NZ(data);
    XLow = data;
}

# LDX 16 bit.
:LDX LDX_OP    is (is_m8=0 &
    (op=0xa2 | op=0xae | op=0xa6 | op=0xbe | op=0xb6)) ... & LDX_OP
{
    local data:2 = LDX_OP;
    flag16_NZ(data);
    X = data;
}

LDY_OP: SEC_OP_X    is (aaa=5) ... & SEC_OP_X  { export SEC_OP_X; }
LDY_OP: ADDR_IMM    is (bbb=0) ... & ADDR_IMM  { export ADDR_IMM; }

# LDY 8 bit.
:LDY LDY_OP    is (is_m8=1 &
    (op=0xa0 | op=0xac | op=0xa4 | op=0xbc | op=0xb4)) ... & LDY_OP
{
    local data:1 = LDY_OP:1;
    flag8_NZ(data);
    YLow = data;
}

# LDY 16 bit.
:LDY LDY_OP    is (is_m8=0 &
    (op=0xa0 | op=0xac | op=0xa4 | op=0xbc | op=0xb4)) ... & LDY_OP
{
    local data:2 = LDY_OP;
    flag16_NZ(data);
    Y = data;
}

# LSR 8 bit.
:LSR SHIFT_OP    is (is_m8=1 &
    (op=0x4a | op=0x4e | op=0x46 | op=0x5e | op=0x56)) ... & SHIFT_OP
{
    local data:1 = SHIFT_OP:1;
    local result:1 = data >> 1;

    SHIFT_OP[0,8] = result;
    flag8_Z(result);
    NF = 0;
    CF = data[0,1];
}

# LSR 16 bit.
:LSR SHIFT_OP    is (is_m8=0 &
    (op=0x4a | op=0x4e | op=0x46 | op=0x5e | op=0x56)) ... & SHIFT_OP
{
    local data:2 = SHIFT_OP;
    local result:2 = data >> 1;

    SHIFT_OP = result;
    flag16_Z(result);
    NF = 0;
    CF = data[0,1];
}

# MVN 8 bit.
:MVN srcbk,destbk    is (is_m8=1 & (op=0x54 ; destbk; srcbk))
{
    local src_bank:1 = srcbk;
    local dest_bank:1 = destbk;
    DBR = dest_bank;
    local src_addr:3;
    local dest_addr:3;

    <move_loop>
    make_addr24(src_addr, src_bank, zext(XLow));
    make_addr24(dest_addr, dest_bank, zext(YLow));
    *:1 dest_addr = *:1 src_addr;

    XLow = XLow + 1;
    YLow = YLow + 1;
    C = C - 1;

    if (C != 0xFFFF) goto <move_loop>;
}

# MVN 16 bit.
:MVN srcbk,destbk    is (is_m8=0 & (op=0x54 ; destbk; srcbk))
{
    local src_bank:1 = srcbk;
    local dest_bank:1 = destbk;
    DBR = dest_bank;
    local src_addr:3;
    local dest_addr:3;

    <move_loop>
    make_addr24(src_addr, src_bank, X);
    make_addr24(dest_addr, dest_bank, Y);
    *:1 dest_addr = *:1 src_addr;

    X = X + 1;
    Y = Y + 1;
    C = C - 1;

    if (C != 0xFFFF) goto <move_loop>;
}

# MVP 8 bit.
:MVP srcbk,destbk    is (is_m8=1 & (op=0x44 ; destbk; srcbk))
{
    local src_bank:1 = srcbk;
    local dest_bank:1 = destbk;
    DBR = dest_bank;
    local src_addr:3;
    local dest_addr:3;

    <move_loop>
    make_addr24(src_addr, src_bank, zext(XLow));
    make_addr24(dest_addr, dest_bank, zext(YLow));
    *:1 dest_addr = *:1 src_addr;

    XLow = XLow - 1;
    YLow = YLow - 1;
    C = C - 1;

    if (C != 0xFFFF) goto <move_loop>;
}

# MVP 16 bit.
:MVP srcbk,destbk    is (is_m8=0 & (op=0x44 ; destbk; srcbk))
{
    local src_bank:1 = srcbk;
    local dest_bank:1 = destbk;
    DBR = dest_bank;
    local src_addr:3;
    local dest_addr:3;

    <move_loop>
    make_addr24(src_addr, src_bank, X);
    make_addr24(dest_addr, dest_bank, Y);
    *:1 dest_addr = *:1 src_addr;

    X = X - 1;
    Y = Y - 1;
    C = C - 1;

    if (C != 0xFFFF) goto <move_loop>;
}

:NOP    is op=0xEA  {}

# ORA 8 bit.
:ORA PRIMARY_OP    is (is_m8=1 &
    (op=0x09 | op=0x0d | op=0x0f | op=0x05 | op=0x12 | op=0x07 | op=0x1d |
     op=0x1f | op=0x19 | op=0x15 | op=0x01 | op=0x11 | op=0x17 | op=0x03 |
     op=0x13)) ... & PRIMARY_OP
{
    local data:1 = PRIMARY_OP:1;

    A = A | data;
    flag8_NZ(A);
}

# ORA 16 bit.
:ORA PRIMARY_OP    is (is_m8=0 &
    (op=0x09 | op=0x0d | op=0x0f | op=0x05 | op=0x12 | op=0x07 | op=0x1d |
     op=0x1f | op=0x19 | op=0x15 | op=0x01 | op=0x11 | op=0x17 | op=0x03 |
     op=0x13)) ... & PRIMARY_OP
{
    local data:2 = PRIMARY_OP:2;

    C = C | data;
    flag16_NZ(C);
}

# SBC with decimal mode is unimplemented.
:SBC PRIMARY_OP    is (is_dec=1 &
    (op=0xe9 | op=0xed | op=0xef | op=0xe5 | op=0xf2 | op=0xe7 | op=0xfd |
     op=0xff | op=0xf9 | op=0xf5 | op=0xe1 | op=0xf1 | op=0xf7 | op=0xe3 |
     op=0xf3)) ... & PRIMARY_OP  unimpl

# SBC 8 bit binary.
:SBC PRIMARY_OP    is (is_dec=0 & is_m8=1 &
    (op=0xe9 | op=0xed | op=0xef | op=0xe5 | op=0xf2 | op=0xe7 | op=0xfd |
     op=0xff | op=0xf9 | op=0xf5 | op=0xe1 | op=0xf1 | op=0xf7 | op=0xe3 |
     op=0xf3)) ... & PRIMARY_OP
{
    local data:1 = ~(PRIMARY_OP:1);
    local result:4;

    result = zext(A) + zext(data) + zext(CF);
    VF = (~zext(A ^ data) & (zext(A) ^ result) & 0x80) != 0;
    CF = result s> 0xFF;

    result8:1 = result:1;
    flag8_NZ(result8);
    A = result8;
}

# SBC 16 bit binary.
:SBC PRIMARY_OP    is (is_dec=0 & is_m8=0 &
    (op=0xe9 | op=0xed | op=0xef | op=0xe5 | op=0xf2 | op=0xe7 | op=0xfd |
     op=0xff | op=0xf9 | op=0xf5 | op=0xe1 | op=0xf1 | op=0xf7 | op=0xe3 |
     op=0xf3)) ... & PRIMARY_OP
{
    local data:2 = ~(PRIMARY_OP:2);
    local result:4;

    result = zext(C) + zext(data) + zext(CF);
    VF = (~zext(C ^ data) & (zext(C) ^ result) & 0x8000) != 0;
    CF = result s> 0xFFFF;

    local result16:2 = result:2;
    flag16_NZ(result16);
    C = result16;
}

# STA 8 bit.
:STA PRIMARY_OP_NO_IMM    is (aaa=4 & is_m8=1) ... & PRIMARY_OP_NO_IMM
{
    PRIMARY_OP_NO_IMM[0,8] = A;
}

# STA 16 bit.
:STA PRIMARY_OP_NO_IMM    is (aaa=4 & is_m8=0) ... & PRIMARY_OP_NO_IMM
{
    PRIMARY_OP_NO_IMM = C;
}
