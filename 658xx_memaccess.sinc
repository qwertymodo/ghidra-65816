# Macros and tables for memory access.

# The 65816 usually accesses memory through a bank/page system, and accesses often wrap to stay
# within the bank or page. This is especially problematic when doing a two-byte memory access: if
# the lower byte is at the end of a bank/page then the upper byte will wrap to the start of the
# bank/page. In this situation the word being accessed is non-contiguous, and Ghidra/sleigh cannot
# cope with this natively.
#
# In order to work around this limitation all memory accesses and addressing modes will have to
# have separate 8 bit and 16 bit implementations. The 16 bit implementations will have to manually
# account for bank/page wrapping and read/write the upper and lower bytes individually.
# This has the side-effect of preventing the use of dynamic references when exporting from
# constructors. And in order to work around that limitation there will need to be separate read
# and write implementations.


macro flag8_N(_acc) {
    local acc:1 = _acc;
    NF = (acc & 0x80) != 0;
}

macro flag8_Z(_acc) {
    local acc:1 = _acc;
    ZF = acc == 0;
}

macro flag8_NZ(_acc) {
    flag8_N(_acc);
    flag8_Z(_acc);
}

macro flag16_N(_acc) {
    local acc:2 = _acc;
    NF = (acc & 0x8000) != 0;
}

macro flag16_Z(_acc) {
    local acc:2 = _acc;
    ZF = acc == 0;
}

macro flag16_NZ(_acc) {
    flag16_N(_acc);
    flag16_Z(_acc);
}

macro push8(_val8) {
    local value:1 = _val8;
    local sp:3 = zext(SP);
    *:1 sp = value;
    SP = SP - 1;
}

macro push16(_val16) {
    local value:2 = _val16;
    local sp:3;

    # High byte.
    sp = zext(SP);
    *:1 sp = value(1);
    SP = SP - 1;

    # Low byte.
    sp = zext(SP);
    *:1 sp = value:1;
    SP = SP - 1;
}

macro pull8(var8) {
    SP = SP + 1;
    local sp:3 = zext(SP);
    var8 = *:1 sp;
}

macro pull16(var16) {
    local sp:3;
    local temp:2;

    # Low byte.
    SP = SP + 1;
    sp = zext(SP);
    temp[0,8] = *:1 sp;

    # High byte.
    SP = SP + 1;
    sp = zext(SP);
    temp[8,8] = *:1 sp;

    var16 = temp;
}

macro push_status_native() {
    local status:1;
    status[7,1] = NF;
    status[6,1] = VF;
    status[5,1] = $(MF);
    status[4,1] = $(XF);
    status[3,1] = DF;
    status[2,1] = IF;
    status[1,1] = ZF;
    status[0,1] = CF;
    push8(status);
}

macro push_status_emulation() {
    local status:1 = 0;
    status[7,1] = NF;
    status[6,1] = VF;
    # bit 5 unused
    status[4,1] = BF;
    status[3,1] = DF;
    status[2,1] = IF;
    status[1,1] = ZF;
    status[0,1] = CF;
    push8(status);
}

# Does not support setting the context flags MF, XF.
macro pull_status_native() {
    local status:1;
    pull8(status);
    NF = status[7,1];
    VF = status[6,1];
    # MF = status[5,1];
    # XF = status[4,1];
    DF = status[3,1];
    IF = status[2,1];
    ZF = status[1,1];
    CF = status[0,1];
}

macro pull_status_emulation() {
    local status:1;
    pull8(status);
    NF = status[7,1];
    VF = status[6,1];
    # bit 5 unused
    BF = status[4,1];
    DF = status[3,1];
    IF = status[2,1];
    ZF = status[1,1];
    CF = status[0,1];
}


# TODO: is explicit use of const space necessary?
# TODO: for all operations that affect the stack, limit the stack pointer when in emulation mode.
# TODO: make sure we're using the data bank register when reading.
# TODO: make sure addressing modes/data access is wrapping to stay within banks if necessary.

# In the 6502/65C02, the effective address formed using zero page indexed addressing from a zero page
# base address of $F0 and an index of $20 is $10; that is, zero page indexed effective addresses wrap around to
# always remain in the zero page. In the emulation mode this is also true. But in native mode, there is no page
# wraparound: a direct page starting at $2000 combined with a direct page base of $20 and a sixteen-bit index
# holding $300 results in an effective address of $2320.  (p52)

# [Speaking about the 65802] While the direct page can be set to the zero page, direct page indexed addresses can cross pages
# in native mode, but wrap on the 6502.  (p58)

# Index wrapping is described on p98.
# Addressing mode syntax on p155.

# [Speaking about the 658xx] Pay particular attention to the peculiarities of the direct page in the emulation mode: as with the 6502
# and 65C02, instructions which use direct page addressing modes will [appear to?] “wrap” to stay within the zero page, but
# only when the direct page register is equal to zero. Opcodes which are not found on the 6502 or 65C02 will not
# wrap at all, even when the direct page is equal to zero in the emulation mode.  (p278)

# The 6502 emulation mode on the 65802 and 65816 processors (e = 1) differs in that the stack pointer’s
# high byte is always $01; direct page indexed addressing always wraps around to remain in the direct page rather
# than crossing over into the next page (so the high direct page byte remains the high byte of all direct page
# addresses formed). The exception to this is that zero page stack wrapping is only enforced for 6502 and 65C02
# instructions, and only when DP = 0 in the case of page zero wrapping. New opcodes will cause effective
# addresses to be generated outside of the zero page or the emulation mode stack page if an effective address
# calculation overflows the low byte.  (p283)


# Combine a low byte and a high byte into one 16 bit word.
# _out: the returned 16 bit word.
# _lo: the least significant byte.
# _hi: the most significant byte.
macro pack_lo_hi(_out, _lo, _hi) {
    local hi8:1 = _hi; local lo8:1 = _lo;
    local hi:2 = zext(hi8); local lo:2 = zext(lo8);
    _out = (hi << 8) | (lo);
}

# Read a byte from some big offset from the start of the data bank, taking wrapping into account.
macro read_data_bank(_out, _offset32) {
    local _offset:4 = _offset32;
    local address:4 = (zext(DBR) << 16) + _offset;
    _out = *:1 (address:3);
}

# Read a byte from some big offset from the stack pointer, taking wrapping into account.
macro read_stack(_out, _offset32) {
    local _offset:4 = _offset32;
    local address32:4 = zext(SP) + _offset;
    local address:3 = zext(address32:2);
    _out = *:1 address;
}

# Read a byte from some big offset from the start of the direct page, taking wrapping into account.
# Additional (more restrictive) wrapping may occur in emulation mode under certain circumstances.
macro read_direct(_out, _offset32) {
    local _offset:4 = _offset32;
    local _ea:3;
    if (($(EF) == 1) && (DPLow == 0)) goto <emu_read_direct>;

    # <not_emu_read_direct>
    # Quote from manual p58:
    # "While the direct page can be set to the zero page, direct page indexed addresses can cross
    # pages in native mode..."
    #
    # So for this part of the macro (native-like mode) the access is modulo 16 bits (always in
    # bank 0).
    local temp:4 = zext(DP) + _offset;
    _ea = zext(temp:2);
    goto <end_read_direct>;

    <emu_read_direct>
    # Quote from manual p278:
    # "Pay particular attention to the peculiarities of the direct page in the emulation mode: as
    # with the 6502 and 65C02, instructions which use direct page addressing modes will
    # [appear to?] “wrap” to stay within the zero page, but only when the direct page register is
    # equal to zero. Opcodes which are not found on the 6502 or 65C02 will not wrap at all, even
    # when the direct page is equal to zero in the emulation mode."
    #
    # This macro is for instructions that exist on the 65(C)02, so exhibit the wrapping behaviour.
    # Higan uses DP for some reason, instead of DPLow. I'm going to assume that's correct.
    _ea = zext(DP | (_offset:1));

    <end_read_direct>
    _out = *:1 _ea;
}

# Read a byte from some big offset from the start of the direct page, taking wrapping into account.
# No additional (more restrictive) wrapping will occur for emulation mode.
macro read_direct_noemu(_out, _offset32) {
    local _offset:4 = _offset32;
    local _ea:3;

    # Quote from manual p58:
    # "While the direct page can be set to the zero page, direct page indexed addresses can cross
    # pages in native mode..."
    #
    # So for this part of the macro (native-like mode) the access is modulo 16 bits (always in
    # bank 0).
    # Since this macro is for instructions that don't exist on the 65(C)02, no additional special
    # wrapping behaviour is necessary.
    local temp:4 = zext(DP) + _offset;
    _ea = zext(temp:2);
    _out = *:1 _ea;
}

@define DATA_EXPORT16 "local data:2; pack_lo_hi(data, data_lo, data_hi); export data"
@define DEREF_EA_EXPORT8 "local data:1 = *:1 ea; export data"
@define DEREF_EA_EXPORT16 "local data:2; pack_lo_hi(data, (*:1 ea_lo), (*:1 ea_hi)); export data"


# Read the contents of the X register. Size depends on XF.
IdxX:    is ctx_XF=1  {
    local data:1 = XLow;
    export data;
}
IdxX:    is ctx_XF=0  {
    local data:2 = X;
    export data;
}

# Read the contents of the Y register. Size depends on XF.
IdxY:    is ctx_XF=1  {
    local data:1 = YLow;
    export data;
}
IdxY:    is ctx_XF=0  {
    local data:2 = Y;
    export data;
}


#####################################
# High level address mode accesses
#####################################

@include "658xx_memaccess_pc.sinc"
@include "658xx_memaccess_other.sinc"


# Absolute.
MemAbsRead8: !$imm16    is imm16  {
    local offset16:2 = imm16;
    local offset:4 = zext(offset16);
    local data:1; read_data_bank(data, offset);
    export data;
}
MemAbsRead16: !$imm16    is imm16  {
    local offset16:2 = imm16;
    local offset:4 = zext(offset16);
    local data_lo:1; read_data_bank(data_lo, offset);
    local data_hi:1; read_data_bank(data_hi, offset + 1);
    $(DATA_EXPORT16);
}

# Absolute indexed by X.
# Indexing allows the access to cross bank boundaries, and even works if the access straddles
# the boundary.
MemAbsIdxXRead8: !$imm16,"X"    is imm16 & IdxX  {
    local offset16:2 = imm16;
    local offset:4 = zext(offset16) + zext(IdxX);
    local data:1; read_data_bank(data, offset);
    export data;
}
MemAbsIdxXRead16: !$imm16,"X"    is imm16 & IdxX  {
    local offset16:2 = imm16;
    local offset:4 = zext(offset16) + zext(IdxX);
    local data_lo:1; read_data_bank(data_lo, offset);
    local data_hi:1; read_data_bank(data_hi, offset + 1);
    $(DATA_EXPORT16);
}

# Absolute indexed by Y.
# Indexing allows the access to cross bank boundaries, and even works if the access straddles
# the boundary.
MemAbsIdxYRead8: !$imm16,"Y"    is imm16 & IdxY  {
    local offset16:2 = imm16;
    local offset:4 = zext(offset16) + zext(IdxY);
    local data:1; read_data_bank(data, offset);
    export data;
}
MemAbsIdxYRead16: !$imm16,"Y"    is imm16 & IdxY  {
    local offset16:2 = imm16;
    local offset:4 = zext(offset16) + zext(IdxY);
    local data_lo:1; read_data_bank(data_lo, offset);
    local data_hi:1; read_data_bank(data_hi, offset + 1);
    $(DATA_EXPORT16);
}

# Absolute long.
MemAbsLongRead8: !>$imm24    is imm24  {
    local ea:3 = imm24;
    $(DEREF_EA_EXPORT8);
}
MemAbsLongRead16: !>$imm24    is imm24  {
    local ea_lo:3 = imm24;
    local ea_hi:3 = ea_lo + 1;
    $(DEREF_EA_EXPORT16);
}

# Absolute long, indexed by X.
MemAbsLongIdxXRead8: !>$imm24,"X"    is imm24 & IdxX  {
    local base:3 = imm24;
    local ea:3 = base + zext(IdxX);
    $(DEREF_EA_EXPORT8);
}
MemAbsLongIdxXRead16: !>$imm24,"X"    is imm24 & IdxX  {
    local base:3 = imm24;
    local ea_lo:3 = base + zext(IdxX);
    local ea_hi:3 = ea_lo + 1;
    $(DEREF_EA_EXPORT16);
}

# Accumulator.
MemAccRead8: "A"    is epsilon  {
    data:1 = A;
    export data;
}
MemAccRead16: "A"    is epsilon  {
    data:2 = C;
    export data;
}

# Direct page.
# DP access may wrap in emulation mode.
MemDPRead8: <$imm8    is imm8  {
    local offset8:1 = imm8;
    local offset:4 = zext(offset8);
    local data:1; read_direct(data, offset);
    export data;
}
MemDPRead16: <$imm8    is imm8  {
    local offset8:1 = imm8;
    local offset:4 = zext(offset8);
    local data_lo:1; read_direct(data_lo, offset);
    local data_hi:1; read_direct(data_hi, offset + 1);
    $(DATA_EXPORT16);
}

# Direct page indexed by X.
# DP access may wrap in emulation mode.
MemDPIdxXRead8: <$imm8,"X"    is imm8 & IdxX  {
    local offset8:1 = imm8;
    local offset:4 = zext(offset8) + zext(IdxX);
    local data:1; read_direct(data, offset);
    export data;
}
MemDPIdxXRead16: <$imm8,"X"    is imm8 & IdxX  {
    local offset8:1 = imm8;
    local offset:4 = zext(offset8) + zext(IdxX);
    local data_lo:1; read_direct(data_lo, offset);
    local data_hi:1; read_direct(data_hi, offset + 1);
    $(DATA_EXPORT16);
}

# Direct page indexed by Y.
# DP access may wrap in emulation mode.
MemDPIdxYRead8: <$imm8,"Y"    is imm8 & IdxY  {
    local offset8:1 = imm8;
    local offset:4 = zext(offset8) + zext(IdxY);
    local data:1; read_direct(data, offset);
    export data;
}
MemDPIdxYRead16: <$imm8,"Y"    is imm8 & IdxY  {
    local offset8:1 = imm8;
    local offset:4 = zext(offset8) + zext(IdxY);
    local data_lo:1; read_direct(data_lo, offset);
    local data_hi:1; read_direct(data_hi, offset + 1);
    $(DATA_EXPORT16);
}

# Direct page indexed by X, indirect.
# DP access may wrap in emulation mode.
MemDPIdxIndRead8: (<$imm8,"X")    is imm8 & IdxX  {
    local offset8:1 = imm8;
    local offset:4 = zext(offset8) + zext(IdxX);

    local ind_lo:1; read_direct(ind_lo, offset);
    local ind_hi:1; read_direct(ind_hi, offset + 1);
    local ind:2; pack_lo_hi(ind, ind_lo, ind_hi);

    offset = zext(ind);
    local data:1; read_data_bank(data, offset);
    export data;
}
MemDPIdxIndRead16: (<$imm8,"X")    is imm8 & IdxX  {
    local offset8:1 = imm8;
    local offset:4 = zext(offset8) + zext(IdxX);

    local ind_lo:1; read_direct(ind_lo, offset);
    local ind_hi:1; read_direct(ind_hi, offset + 1);
    local ind:2; pack_lo_hi(ind, ind_lo, ind_hi);

    offset = zext(ind);
    local data_lo:1; read_data_bank(data_lo, offset);
    local data_hi:1; read_data_bank(data_hi, offset + 1);
    $(DATA_EXPORT16);
}

# Direct page indirect.
# DP access may wrap in emulation mode.
MemDPIndRead8: (<$imm8)    is imm8  {
    local offset8:1 = imm8;
    local offset:4 = zext(offset8);

    local ind_lo:1; read_direct(ind_lo, offset);
    local ind_hi:1; read_direct(ind_hi, offset + 1);
    local ind:2; pack_lo_hi(ind, ind_lo, ind_hi);

    offset = zext(ind);
    local data:1; read_data_bank(data, offset);
    export data;
}
MemDPIndRead16: (<$imm8)    is imm8  {
    local offset8:1 = imm8;
    local offset:4 = zext(offset8);

    local ind_lo:1; read_direct(ind_lo, offset);
    local ind_hi:1; read_direct(ind_hi, offset + 1);
    local ind:2; pack_lo_hi(ind, ind_lo, ind_hi);

    offset = zext(ind);
    local data_lo:1; read_data_bank(data_lo, offset);
    local data_hi:1; read_data_bank(data_hi, offset + 1);
    $(DATA_EXPORT16);
}

# Direct page indirect long.
# No special wrapping.
MemDPIndLongRead8: [<$imm8]    is imm8  {
    local offset8:1 = imm8;
    local offset:4 = zext(offset8);

    local ind_lo:1; read_direct_noemu(ind_lo, offset);
    local ind_hi:1; read_direct_noemu(ind_hi, offset + 1);
    local ind_bank:1; read_direct_noemu(ind_bank, offset + 2);

    local ea:3 = (ind_bank << 16) | (ind_hi << 8) | ind_lo;
    $(DEREF_EA_EXPORT8);
}
MemDPIndLongRead16: [<$imm8]    is imm8  {
    local offset8:1 = imm8;
    local offset:4 = zext(offset8);

    local ind_lo:1; read_direct_noemu(ind_lo, offset);
    local ind_hi:1; read_direct_noemu(ind_hi, offset + 1);
    local ind_bank:1; read_direct_noemu(ind_bank, offset + 2);

    local ea_lo:3 = (ind_bank << 16) | (ind_hi << 8) | ind_lo;
    local ea_hi:3 = ea_lo + 1;
    $(DEREF_EA_EXPORT16);
}

# Direct page indirect, indexed by Y.
# DP access may wrap in emulation mode.
MemDPIndIdxRead8: (<$imm8),"Y"    is imm8 & IdxY  {
    local offset8:1 = imm8;
    local offset:4 = zext(offset8);

    local ind_lo:1; read_direct(ind_lo, offset);
    local ind_hi:1; read_direct(ind_hi, offset + 1);
    local ind:2; pack_lo_hi(ind, ind_lo, ind_hi);

    offset = zext(ind) + zext(IdxY);
    local data:1; read_data_bank(data, offset);
    export data;
}
MemDPIndIdxRead16: (<$imm8),"Y"    is imm8 & IdxY  {
    local offset8:1 = imm8;
    local offset:4 = zext(offset8);

    local ind_lo:1; read_direct(ind_lo, offset);
    local ind_hi:1; read_direct(ind_hi, offset + 1);
    local ind:2; pack_lo_hi(ind, ind_lo, ind_hi);

    offset = zext(ind) + zext(IdxY);
    local data_lo:1; read_data_bank(data_lo, offset);
    local data_hi:1; read_data_bank(data_hi, offset + 1);
    $(DATA_EXPORT16);
}

# Direct page indirect long, indexed by Y.
# No special wrapping.
MemDPIndLongIdxRead8: [<$imm8],"Y"    is imm8 & IdxY  {
    local offset8:1 = imm8;
    local offset:4 = zext(offset8);

    local ind_lo:1; read_direct_noemu(ind_lo, offset);
    local ind_hi:1; read_direct_noemu(ind_hi, offset + 1);
    local ind_bank:1; read_direct_noemu(ind_bank, offset + 2);

    local ea:3 = ((ind_bank << 16) | (ind_hi << 8) | ind_lo) + zext(IdxY);
    $(DEREF_EA_EXPORT8);
}
MemDPIndLongIdxRead16: [<$imm8],"Y"    is imm8 & IdxY  {
    local offset8:1 = imm8;
    local offset:4 = zext(offset8);

    local ind_lo:1; read_direct_noemu(ind_lo, offset);
    local ind_hi:1; read_direct_noemu(ind_hi, offset + 1);
    local ind_bank:1; read_direct_noemu(ind_bank, offset + 2);

    local ea_lo:3 = ((ind_bank << 16) | (ind_hi << 8) | ind_lo) + zext(IdxY);
    local ea_hi:3 = ea_lo + 1;
    $(DEREF_EA_EXPORT16);
}

# Immediate.
MemImmRead8: #$imm8    is imm8  {
    local imm:1 = imm8;
    export imm;
}
MemImmRead16: #$imm8    is imm16  {
    local imm:2 = imm16;
    export imm;
}
# Select the size based on MF.
MemImmReadMF: MemImmRead8    is ctx_MF=1 & MemImmRead8  {
    export MemImmRead8;
}
MemImmReadMF: MemImmRead16    is ctx_MF=0 & MemImmRead16  {
    export MemImmRead16;
}

# Stack relative.
MemSRRead8: $imm8,"S"    is imm8  {
    local imm:1 = imm8;
    local offset:4 = zext(imm);

    local data:1; read_stack(data, offset);
    export data;
}
MemSRRead16: $imm8,"S"    is imm8  {
    local imm:1 = imm8;
    local offset:4 = zext(imm);

    local data_lo:1; read_stack(data_lo, offset);
    local data_hi:1; read_stack(data_hi, offset + 1);
    $(DATA_EXPORT16);
}

# Stack relative indirect, indexed by Y.
MemSRIndRead8: ($imm8,"S"),"Y"    is imm8 & IdxY  {
    local imm:1 = imm8;
    local offset:4 = zext(imm);

    local ind_lo:1; read_stack(ind_lo, offset);
    local ind_hi:1; read_stack(ind_hi, offset + 1);
    local ind:2; pack_lo_hi(ind, ind_lo, ind_hi);

    offset = zext(ind) + zext(IdxY);
    local data:1; read_data_bank(data, offset);
    export data;
}
MemSRIndRead16: ($imm8,"S"),"Y"    is imm8 & IdxY  {
    local imm:1 = imm8;
    local offset:4 = zext(imm);

    local ind_lo:1; read_stack(ind_lo, offset);
    local ind_hi:1; read_stack(ind_hi, offset + 1);
    local ind:2; pack_lo_hi(ind, ind_lo, ind_hi);

    offset = zext(ind) + zext(IdxY);
    local data_lo:1; read_data_bank(data_lo, offset);
    local data_hi:1; read_data_bank(data_hi, offset + 1);
    $(DATA_EXPORT16);
}
